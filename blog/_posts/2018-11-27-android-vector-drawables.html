---
layout: post
title: Android Vector Drawables
date: '2018-11-27T10:16:51+05:30'
tags:
- android
- vector graphics
- computergraphics
- vector-drawables
tumblr_url: https://cgknowhow.tumblr.com/post/180541087849/android-vector-drawables
image: assets/images/vec_drawable.jpg
---
<p>There are two basic ways an image can be represented in: Bitmaps and Vector Drawables. Normal Bitmaps are represented in the form of pixels in a grid. A <b>Vector Drawable</b>  defines the image in the form of geometry, i.e as a set of points in the Cartesian plane, connected through lines and curves, with their associated color information.<br/></p><p>In this post we’ll be focusing on static Vector Drawables and some of their advanced features. Animated Vector Drawables will be covered very briefly.</p><h2>Why Vector Drawables?</h2><p>Vector Drawables are, </p><ul><li><b>Sharp</b></li></ul><p>All Bitmaps have a specific resolution, which when displayed on a different density display may pixelate or might introduce unwanted artifacts. Vector Drawables look sharp on each display independent of display density, i.e. the same file is resized for different screen densities.</p><ul><li>Small</li></ul><p>A Bitmap of higher resolution means more pixels. More pixels means larger file size. Vector Drawables do not store pixels therefore they are of the same size independent of display density. This results in smaller APK files and less developer maintenance.</p><ul><li><b>Flexible</b></li></ul><p>Vector Drawables are highly flexible. One can also animate them using multiple XML files.</p><p>The support for Vector Drawables was added in API Level 21(Lollipop). Prior to this release if anyone wanted to represent images through Vector Graphics they had to do it manually though Java Code. If Bitmaps were used, developers had to use different images, one for each display resolution. Imagine using animated Bitmaps in such a situation! </p><p>There are two classes that help you use Vector Drawables: <b>VectorDrawable</b> and <b>AnimatedVectorDrawable</b>.</p><p>There are two basic ways an image can be represented in: Bitmaps and Vector Drawables. Normal Bitmaps are represented in the form of pixels in a grid. A Vector Drawable  defines the image in the form of geometry, i.e as a set of points in the Cartesian plane, connected through lines and curves, with their associated color information.</p><p>In this post we’ll be focusing on static Vector Drawables and some of their advanced features. Animated Vector Drawables will be covered very briefly.</p><p><b><br/><br/></b></p><h2>The VectorDrawable Class</h2><p>This class defines a static drawable object. It is defined in a manner similar to the SVG format.</p><figure data-orig-width="299" data-orig-height="167"><img src="https://64.media.tumblr.com/afaca8d515f0a1097378a4c3754c9a37/tumblr_inline_piu3ynaJy31v99f5f_540.png" alt="image" data-orig-width="299" data-orig-height="167"/></figure><p>Image Courtesy: developer.android.com</p><p>It follows a tree hierarchy consisting of groups and paths. The <b>path</b> contains the actual geometric data to draw the object. The <b>group</b> contains data for transformation of the shape. The <b>path</b> is always a leaf of the tree. The <b>path</b> will be joined in same order in which it appears in the file.</p><p>The <b>group</b> text is an internal node of the tree. A path object inherits all the transformation of it’s ancestor groups.</p><p>Let’s take a look at a sample Vector Graphic as an SVG file and its corresponding XML Vector Drawable.<br/></p><p><b>SVG</b></p><p><b></b></p><blockquote><p>&lt;svg xmlns=&ldquo;http://www.w3.org/2000/svg&rdquo; width=&ldquo;24&rdquo; height=&ldquo;24&rdquo; viewBox=&ldquo;0 0 24 24&rdquo;&gt;</p><p>&lt;path fill-opacity=&ldquo;.3&rdquo; d=&ldquo;M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V8h5.47L13 7v1h4V5.33C17 4.6 16.4 4 15.67 4z&rdquo;/&gt;</p><p>&lt;path d=&ldquo;M13 12.5h2L11 20v-5.5H9L12.47 8H7v12.67C7 21.4 7.6 22 8.33 22h7.33c.74 0 1.34-.6 1.34-1.33V8h-4v4.5z&rdquo;/&gt;</p><p>&lt;path d=&ldquo;M0 0h24v24H0z&rdquo; fill=&ldquo;none&rdquo;/&gt;</p><p>&lt;/svg&gt;<br/><b><br/></b></p></blockquote><p><b>XML</b></p><blockquote><p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?&gt;<br/>&lt;vector xmlns:android=&ldquo;http://schemas.android.com/apk/res/android&rdquo;<br/>    android:width=&ldquo;24dp&rdquo;<br/>    android:height=&ldquo;24dp&rdquo;<br/>    android:viewportWidth=&ldquo;24&rdquo;<br/>    android:viewportHeight=&ldquo;24&rdquo;&gt;<br/><br/>    &lt;path<br/>        android:fillColor=&ldquo;#000000&rdquo;<br/>        android:fillAlpha=&ldquo;.3&rdquo;<br/>        android:pathData=&ldquo;M15.67 4H14V2h-4v2H8.33C7.6 4 7 4.6 7 5.33V8h5.47L13 7v1h4V5.33C17 4.6 16.4 4 15.67 4z&rdquo; /&gt;<br/>    &lt;path<br/>        android:fillColor=&ldquo;#000000&rdquo;<br/>        android:pathData=&ldquo;M13 12.5h2L11 20v-5.5H9L12.47 8H7v12.67C7 21.4 7.6 22 8.33 22h7.33c0.74 0 1.34-0.6 1.34-1.33V8h-4v4.5z&rdquo; /&gt;<br/>    &lt;path<br/>        android:pathData=&ldquo;M0 0h24v24H0z&rdquo; /&gt;<br/>&lt;/vector&gt;</p></blockquote><p><b></b></p><p>This Vector Drawable renders an image of a battery in charging mode.</p><figure data-orig-width="36" data-orig-height="36"><img src="https://64.media.tumblr.com/c3a315098f29410a22390a6244d02b72/tumblr_inline_piu4btYR9x1v99f5f_540.png" alt="image" data-orig-width="36" data-orig-height="36"/></figure><p><b></b></p><p>There’s a lot more you can do with Vector Drawables. For example <b>you can specify the tint for the image</b>. You needn’t worry if the SVG the designer gave has the right shade of grey you need. The same Vector Drawable renders with different colors according to the set theme.</p><figure data-orig-width="375" data-orig-height="547" class="tmblr-full"><img src="https://64.media.tumblr.com/2b88a1e984cd97843360c9a4eaf08e84/tumblr_inline_piu4ddgfiv1v99f5f_540.png" alt="image" data-orig-width="375" data-orig-height="547"/></figure><p><b></b></p><p>The same image rendered in a light and dark theme.</p><p>(Image Courtesy: Android Dev Summit ‘18)</p><p>All you need to do to set the tint is add this attribute to the vector:</p><blockquote><p>android:tint=&ldquo;?attr/colorControlNormal&rdquo;</p></blockquote><p>You can also use theme colors for specific parts of your image. For example in order to use colorPrimary in you image add this attribute to your path:</p><blockquote><p>android:fillColor=&ldquo;?attr/colorPrimary&rdquo;</p></blockquote><figure data-orig-width="286" data-orig-height="230"><img src="https://64.media.tumblr.com/d303b75698bdf7660ab3d41912fbf0a9/tumblr_inline_piu4ffrcgJ1v99f5f_540.png" alt="image" data-orig-width="286" data-orig-height="230"/></figure><figure data-orig-width="238" data-orig-height="241"><img src="https://64.media.tumblr.com/73d5bb703bf01bd6b1b4b87f74733703/tumblr_inline_piu4ffXzky1v99f5f_540.png" alt="image" data-orig-width="238" data-orig-height="241"/></figure><p><b><br/></b>The same images rendered with different primary colors.<b><br/></b></p><p>(Image Courtesy: Android Dev Summit ‘18)</p><p>Many a times we need to change the color of icons depending on the state of the button. These changes might be as minor as a different colored stroke. You can accomplish this using different colored images, but when the rendering is the same for most of the part, using ColorStateList inside the Vector Drawable is a much better way. You can avoid a lot of duplication in this manner. </p><p>The way to accomplish this is the same as that of a regular ColorStateList. Create a ColorStateList in the color resource directory, and use a reference to it in the fillColor attribute in the path.</p><p>If your ColorStateList is csl_image.xml, the add this line:</p><blockquote><p>android:fillColor=&ldquo;@color/csl_image&rdquo;</p></blockquote><p>Vectors also support gradients. You can have three types of gradients:</p><ul><li>Linear<br/></li></ul><blockquote><p>&lt;gradient android:startColor=&ldquo;#1b82bd&quot;android:endColor=&rdquo;#a242b4&quot; android:startX=&ldquo;12&rdquo; android:endX=&ldquo;12&rdquo; android:startY=&ldquo;0&rdquo; android:endY=&ldquo;24&rdquo; android:type=&ldquo;linear&rdquo;/&gt;</p></blockquote><figure data-orig-width="365" data-orig-height="370" class="tmblr-full"><img src="https://64.media.tumblr.com/c48aebc089e266caca1f1bf3ccb15584/tumblr_inline_piu4hgbA1S1v99f5f_540.png" alt="image" data-orig-width="365" data-orig-height="370"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)<br/></p><p><b><br/></b></p><ul><li>Radial<br/></li></ul><blockquote><p>&lt;gradient android:startColor=&ldquo;#1b82bd&quot;android:endColor=&rdquo;#a242b4&quot; android:centerX=&ldquo;0&rdquo; android:centerY=&ldquo;12&rdquo; android:type=&ldquo;radial&rdquo;/&gt;</p></blockquote><figure data-orig-width="362" data-orig-height="360" class="tmblr-full"><img src="https://64.media.tumblr.com/3043c870d02d156cd7e20f748f22ea16/tumblr_inline_piu4mo7ao11v99f5f_540.png" alt="image" data-orig-width="362" data-orig-height="360"/></figure><ul><li>Sweep</li></ul><blockquote><p>&lt;gradient android:startColor=&ldquo;#1b82bd&quot;android:endColor=&rdquo;#a242b4&quot; android:centerX=&ldquo;0&rdquo; android:centerY=&ldquo;12&rdquo; android:type=&ldquo;sweep&rdquo;/&gt;\</p></blockquote><figure data-orig-width="362" data-orig-height="365" class="tmblr-full"><img src="https://64.media.tumblr.com/02dda3cfe2da1b5d45666c937a4912e9/tumblr_inline_piu4ka3GLu1v99f5f_540.png" alt="image" data-orig-width="362" data-orig-height="365"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)</p><p>We can also define individual color stops using &lt;item&gt; tag to get more fine grained gradients as show below:</p><blockquote><p>&lt;gradient&hellip;&gt;<br/>	&lt;item android:offset=&ldquo;0.0&rdquo;<br/>          android:color=&ldquo;#1b82bd&rdquo;/&gt;<br/>	&lt;item android:offset=&ldquo;0.72&rdquo;<br/>          android:color=&ldquo;#6f5fb8&rdquo;/&gt;<br/>	&lt;item android:offset=&ldquo;1.0&rdquo;<br/>          android:color=&ldquo;#a242b4&rdquo;/&gt;<br/>&lt;/gradient&gt;</p></blockquote><p><b></b></p><p>This sets the color at 72% of the gradient direction parameter.</p><figure data-orig-width="367" data-orig-height="367" class="tmblr-full"><img src="https://64.media.tumblr.com/7e7c4438f9956da9844c9921a609b7e9/tumblr_inline_piu4ouguvV1v99f5f_540.png" alt="image" data-orig-width="367" data-orig-height="367"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)</p><p>Just as we define <b>ColorStateLists</b> in the color resource directory, we can define gradients and then add their reference in our Vector Drawable in the fillColor attribute.</p><p>An alternative to this is to define the gradient using inline resource syntax to embed it inside the vector definition itself as shown below.</p><blockquote><p>&lt;vector&hellip;&gt;<br/>      &lt;path&hellip;&gt;<br/>	&lt;aapt:attr name=&ldquo;android:fillColor&rdquo;&gt;<br/>      &lt;gradient <br/>        android:type=&ldquo;sweep&rdquo;<br/>        android:centerX=&ldquo;0&rdquo;<br/>        android:centerY=&ldquo;0&rdquo;<br/>        android:startColor=&ldquo;#1b82bd&rdquo;<br/>        android:endColor=&ldquo;#a242b4&rdquo;</p><p>      &lt;/aapt:attr&gt;</p><p>      &lt;/path&gt;<br/>&lt;/vector&gt;</p></blockquote><p>Here the AAPT(Android Asset Packaging Tool) will extract this to a color resource at build time and insert a reference for it.Gradients are very useful in situations where you need shadows in Vector Drawables. Vector don’t support shadows, but it can be faked using gradients. You can also use it to create customised spinners using a radial gradient.</p><p>If the gradient doesn’t fill the entire image, you may choose to so any of the following:</p><ul><li><b>Clamp</b><br/></li></ul><p>This is the default mode. It just continues the color outwards from the last offset point</p><p>You may accomplish this by adding the following line in the gradient:</p><blockquote><p>	&lt;gradient&hellip;<br/>	  android:tileMode=&ldquo;clamp&rdquo;/&gt;</p></blockquote><figure data-orig-width="276" data-orig-height="298"><img src="https://64.media.tumblr.com/fad5b9a4b6ff4eb60f129107e5012c9b/tumblr_inline_piu4s4U4LY1v99f5f_540.png" alt="image" data-orig-width="276" data-orig-height="298"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)</p><ul><li><b>Repeat</b><br/></li></ul><p>This repeats the gradient until the whole image is filled.</p><p>You may accomplish this by adding the following line in the gradient:</p><blockquote><p>	&lt;gradient&hellip;<br/>	  android:tileMode=&ldquo;repeat&rdquo;/&gt;</p></blockquote><figure data-orig-width="290" data-orig-height="290"><img src="https://64.media.tumblr.com/e3bb05888b9d84656c6355377f2d31ca/tumblr_inline_piu4teDfZF1v99f5f_540.png" alt="image" data-orig-width="290" data-orig-height="290"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)</p><ul><li><b>Mirror<br/></b></li></ul><p>This goes back and forth through the gradient.</p><p>You may accomplish this by adding the following line in the gradient:</p><blockquote><p>	&lt;gradient&hellip;<br/>	  android:tileMode=&ldquo;mirror&rdquo;/&gt;</p></blockquote><figure data-orig-width="286" data-orig-height="293"><img src="https://64.media.tumblr.com/8957cce3fb992edaca1408d6b4054444/tumblr_inline_piu4usfjUj1v99f5f_540.png" alt="image" data-orig-width="286" data-orig-height="293"/></figure><p>(Image Courtesy: Android Dev Summit ‘18)<br/></p><p>We can also make gradients that do not go from color to color but have regions of solid color.<br/></p><figure data-orig-width="293" data-orig-height="290"><img src="https://64.media.tumblr.com/ed3749d297a667d027ad82853779c6c3/tumblr_inline_piu4w013rH1v99f5f_540.png" alt="image" data-orig-width="293" data-orig-height="290"/></figure><p><b><br/></b></p><p>This can be accomplished by using the same color between two color stops, as shown below:</p><blockquote><p>&lt;gradient&hellip;&gt;<br/>	&lt;item android:offset=&ldquo;0.0&rdquo;<br/>          android:color=&ldquo;#1b82bd&rdquo;/&gt;<br/>	&lt;item android:offset=&ldquo;0.5&rdquo;<br/>          android:color=&ldquo;#1b82bd&rdquo;/&gt;<br/>	&lt;item android:offset=&ldquo;0.5&rdquo;<br/>          android:color=&ldquo;#a242b4&rdquo;/&gt;<br/>	&lt;item android:offset=&ldquo;1.0&rdquo;<br/>          android:color=&ldquo;#a242b4&rdquo;/&gt;<br/>&lt;/gradient&gt;</p></blockquote><p>Vector Drawables are great to reduce the size of the APK file, and reduce the number of images required.They are extremely flexible, but sometimes they come with a significant performance trade-off. Therefore VectorDrawables should be used only when the image is simple up-to a maximum size of 200 x 200 dp, for example icons for Buttons. Shapes should be used instead of Vector Graphics wherever possible.</p><h2>The AnimatedVectorDrawable Class</h2><p>This class adds animation to the properties of a VectorDrawable. We can define animated vector drawables in two ways:</p><ul><li><b>Using three XML files</b><br/></li></ul><p>A VectorDrawable file, an AnimatedVectorDrawable file and an animator XML file.</p><ul><li><b>Using a single XML file</b><br/></li></ul><p>You can also merge related XML files using XML Bundle Format.</p><p>To support vector drawable and animated vector drawable on devices running platform versions lower than Android 5.0 (API level 21), VectorDrawableCompat  and AnimatedVectorDrawableCompat are available through two support libraries: support-vector-drawable and animated-vector-drawable, respectively.</p><p>Support Library 25.4.0 and higher supports the following features:</p><ul><li><b>Path Morphing</b> (PathType evaluator) Used to morph one path into another path.<br/></li><li><b>Path Interpolation</b> Used to define a flexible interpolator (represented as a path) instead of the system-defined interpolators like LinearInterpolator.<br/></li></ul><p>Support Library 26.0.0-beta1 and higher supports the following features:</p><ul><li><b>Move along path</b> The geometry object can move around, along an arbitrary path, as part of an animation.<br/></li></ul><p>For more information about Animated Vector Drawables you can refer to the links posted at the end of the post.</p><h2>Performance trade-off for Vector Drawables</h2><p>Although the XML file used for Vector Drawables is usually smaller than conventional PNG images, it has significant computational overhead at runtime in case the drawn object is complex. When the image is rendered for the first time, a Bitmap cache is created to optimize redrawing performance. Whenever the image needs to be redrawn, the same Bitmap cache is used unless the image size is changed. So, for example you rotate your device, if the size of the rendered image remains the same, it will be rendered using the same cach otherwise the cache will be rebuilt. Therefore in comparison to raster images they take longer to render for the first time. </p><p>As the time taken to draw them is longer, Google recommends a maximum size of <b>200 x 200 dp</b>.</p><h2>Conclusion</h2><p>Vector Drawables are great to reduce the size of the APK file, and reduce the number of images required.They are extremely flexible, but sometimes they come with a significant performance trade-off. Therefore VectorDrawables should be used only when the image is simple upto a maximum size of 200 x 200 dp, for example icons for Buttons. Shapes should be used instead of Vector Graphics wherever possible.</p><h2>Useful Links</h2><ul><li><b><a href="https://developer.android.com/studio/write/vector-asset-studio.html">Adding multi-density vector graphics in Android Studio</a></b><br/></li><li><b><a href="https://upday.github.io/blog/vector_drawables_optimisation/">Optimizing the Performance of Vector Drawables</a></b><br/></li><li><b><b><a href="https://uxdesign.cc/harnessing-the-power-of-animated-vector-drawables-6c700c7d7ef6">Harnessing the Power of Animated vector Drawables</a></b><br/></b></li><li><b><b><b><a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources">Vector Drawables Overview</a></b><br/></b></b></li><li><b><b><b><b><a href="https://www.youtube.com/watch?v=Uz99np2Hat4">Advanced VectorDrawable Rendering (Android Dev Summit &lsquo;18)</a></b><br/></b></b></b></li></ul>
